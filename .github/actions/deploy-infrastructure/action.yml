name: 'Deploy Infrastructure'
description: 'Deploy CDK infrastructure stacks for the specified environment'

inputs:
  environment:
    description: 'Environment to deploy (staging|production)'
    required: true
  aws-region:
    description: 'AWS region'
    required: false
    default: 'us-east-1'
  deployment-strategy:
    description: 'Deployment strategy (individual|shared)'
    required: false
    default: 'individual'
  require-approval:
    description: 'Require CDK approval for deployment'
    required: false
    default: 'never'
  default-ec2-instance-id:
    description: 'Default EC2 instance ID for shared deployments'
    required: false
    default: 'i-0e42eb553386cc529'

outputs:
  deployment-status:
    description: 'Deployment status (success|failed)'
    value: ${{ steps.deploy.outputs.status }}
  stack-outputs:
    description: 'Key deployment outputs (JSON)'
    value: ${{ steps.outputs.outputs.stack-outputs }}

runs:
  using: 'composite'
  steps:
    - name: Setup Node.js for CDK
      uses: actions/setup-node@v4
      with:
        node-version: '22'
        cache: 'yarn'
        
    - name: Enable Corepack
      shell: bash
      run: |
        set -euo pipefail
        corepack enable
        
    - name: Setup Yarn
      shell: bash
      run: |
        set -euo pipefail
        corepack prepare yarn@4.9.4 --activate
        
    - name: Install CDK dependencies
      shell: bash
      run: |
        set -euo pipefail
        cd cdk
        yarn install --immutable
        
    - name: Build Lambda processor
      shell: bash
      run: |
        set -euo pipefail
        echo "üî® Building Lambda processor..."
        
        # Install Lambda dependencies
        cd lambda
        yarn install --immutable
        
        # Ensure output directory exists
        mkdir -p ../cdk/dist/lambda-processor
        
        # Compile TypeScript to JavaScript
        npx tsc
        
        echo "‚úÖ Lambda processor compiled successfully"
        echo "üìÅ Compiled files:"
        ls -la ../cdk/dist/lambda-processor/
        
    - name: Deploy infrastructure stacks
      id: deploy
      shell: bash
      run: |
        set -euo pipefail
        ENVIRONMENT="${{ inputs.environment }}"
        STRATEGY="${{ inputs.deployment-strategy }}"
        APPROVAL="${{ inputs.require-approval }}"
        
        echo "üöÄ Deploying infrastructure for $ENVIRONMENT using $STRATEGY strategy..."
        
        cd cdk
        
        # Set CDK environment variable for the app
        export CDK_ENVIRONMENT="$ENVIRONMENT"
        
        if [ "$STRATEGY" = "shared" ]; then
          echo "üì¶ Deploying shared multi-environment stacks..."
          npx cdk deploy SoundBite-Shared-* --require-approval "$APPROVAL" --outputs-file ../deployment-outputs.json
        else
          echo "üì¶ Deploying individual environment stacks..."
          
          # Get the environment prefix from CDK
          PREFIX=$(npx cdk list | grep -E "SoundBite-.*-Database" | head -1 | sed 's/SoundBite-\(.*\)-Database/\1/')
          echo "üîç Detected environment prefix: $PREFIX"
          
          # For staging and production, check if EC2 instance exists, create if needed
          if [ "$ENVIRONMENT" = "staging" ] || [ "$ENVIRONMENT" = "production" ]; then
            echo "üîç Checking for existing shared EC2 instance from CloudFormation..."
            
            # Dynamically check if API stack exists and has an instance
            STACK_NAME="SoundBite-$PREFIX-API"
            INSTANCE_ID=$(aws cloudformation describe-stacks \
              --stack-name "$STACK_NAME" \
              --query "Stacks[0].Outputs[?OutputKey=='ApiInstanceId'].OutputValue" \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "None" ]; then
              # Check if the instance is still running
              INSTANCE_STATE=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query 'Reservations[0].Instances[0].State.Name' --output text 2>/dev/null || echo "not-found")
              
              if [ "$INSTANCE_STATE" = "running" ]; then
                echo "‚úÖ Found existing EC2 instance: $INSTANCE_ID (state: $INSTANCE_STATE)"
                echo "‚ö†Ô∏è  Skipping API stack for $ENVIRONMENT - using existing EC2 instance"
                npx cdk deploy SoundBite-$PREFIX-Database SoundBite-$PREFIX-Storage SoundBite-$PREFIX-Queue SoundBite-$PREFIX-Compute --require-approval "$APPROVAL" --outputs-file ../deployment-outputs.json
              else
                echo "‚ùå EC2 instance $INSTANCE_ID not running (state: $INSTANCE_STATE)"
                echo "üèóÔ∏è  Deploying all stacks including API to create/update EC2 instance..."
                npx cdk deploy SoundBite-$PREFIX-* --require-approval "$APPROVAL" --outputs-file ../deployment-outputs.json
              fi
            else
              echo "‚ùå No existing EC2 instance found (stack $STACK_NAME not found or has no instance)"
              echo "üèóÔ∏è  Deploying all stacks including API to create EC2 instance..."
              npx cdk deploy SoundBite-$PREFIX-* --require-approval "$APPROVAL" --outputs-file ../deployment-outputs.json
              
              # Wait for cloud-init to complete after creating a new instance
              echo "‚è≥ Waiting for cloud-init to complete on new instance..."
              INSTANCE_ID=$(aws cloudformation describe-stacks \
                --stack-name "$STACK_NAME" \
                --query "Stacks[0].Outputs[?OutputKey=='ApiInstanceId'].OutputValue" \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "None" ]; then
                echo "üîç Waiting for instance $INSTANCE_ID to be ready..."
                aws ec2 wait instance-status-ok --instance-ids "$INSTANCE_ID" --region "${{ inputs.aws-region }}"
                echo "‚úÖ Instance is running and healthy"
                
                # Wait for cloud-init to finish
                echo "‚è≥ Waiting for cloud-init to complete..."
                aws ssm wait command-executed \
                  --command-id "$(aws ssm send-command \
                    --instance-ids "$INSTANCE_ID" \
                    --document-name "AWS-RunShellScript" \
                    --parameters 'commands=["cloud-init status --wait"]' \
                    --region "${{ inputs.aws-region }}" \
                    --query 'Command.CommandId' \
                    --output text)" \
                  --region "${{ inputs.aws-region }}"
                echo "‚úÖ Cloud-init completed successfully"
              fi
            fi
          else
            npx cdk deploy SoundBite-$PREFIX-* --require-approval "$APPROVAL" --outputs-file ../deployment-outputs.json
          fi
        fi
        
        echo "‚úÖ Infrastructure deployment completed successfully!"
        echo "status=success" >> $GITHUB_OUTPUT
        
    - name: Extract deployment outputs
      id: outputs
      shell: bash
      run: |
        set -euo pipefail
        if [ -f "../deployment-outputs.json" ]; then
          echo "üìã Extracting deployment outputs..."
          cat ../deployment-outputs.json | jq -c . > /tmp/outputs.json
          echo "stack-outputs=$(cat /tmp/outputs.json)" >> $GITHUB_OUTPUT
        else
          echo "stack-outputs={}" >> $GITHUB_OUTPUT
        fi
        
    - name: Verify infrastructure deployment
      shell: bash
      run: |
        set -euo pipefail
        ENVIRONMENT="${{ inputs.environment }}"
        
        echo "üîç Verifying infrastructure deployment..."
        
        # Get the environment prefix from CDK (same logic as deployment)
        cd cdk
        export CDK_ENVIRONMENT="$ENVIRONMENT"
        PREFIX=$(npx cdk list | grep -E "SoundBite-.*-Database" | head -1 | sed 's/SoundBite-\(.*\)-Database/\1/')
        echo "üîç Using prefix for verification: $PREFIX"
        cd ..
        
        # Check if stacks exist
        STACKS=$(aws cloudformation list-stacks \
          --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE \
          --query "StackSummaries[?starts_with(StackName, 'SoundBite-$PREFIX-')].StackName" \
          --output text)
        
        if [ -z "$STACKS" ]; then
          echo "‚ùå No stacks found for environment $ENVIRONMENT"
          exit 1
        fi
        
        echo "‚úÖ Found stacks: $STACKS"
        
        # Verify key resources exist
        echo "üîç Verifying key resources..."
        
        # Check Lambda function (uses environment name)
        if aws lambda get-function --function-name "SoundBite-$ENVIRONMENT-processor" >/dev/null 2>&1; then
          echo "‚úÖ Lambda function exists"
        else
          echo "‚ùå Lambda function not found"
          exit 1
        fi
        
        # Check SQS queue (uses environment name)
        if aws sqs get-queue-url --queue-name "SoundBite-$ENVIRONMENT-SoundbiteQueue" >/dev/null 2>&1; then
          echo "‚úÖ SQS queue exists"
        else
          echo "‚ùå SQS queue not found"
          exit 1
        fi
        
        # Check DynamoDB table (uses environment name)
        if aws dynamodb describe-table --table-name "SoundBite-$ENVIRONMENT-SoundbitesTable" >/dev/null 2>&1; then
          echo "‚úÖ DynamoDB table exists"
        else
          echo "‚ùå DynamoDB table not found"
          exit 1
        fi
        
        # Check S3 bucket
        # S3 bucket names include account ID suffix, so we need to find the actual bucket name
        BUCKET_PREFIX="soundbite-$ENVIRONMENT-soundbites"
        BUCKET_NAME=$(aws s3 ls --region us-east-1 | grep "$BUCKET_PREFIX" | awk '{print $3}' | head -1)
        
        if [ -n "$BUCKET_NAME" ] && aws s3 ls "s3://$BUCKET_NAME" >/dev/null 2>&1; then
          echo "‚úÖ S3 bucket exists: $BUCKET_NAME"
        else
          echo "‚ùå S3 bucket not found with prefix: $BUCKET_PREFIX"
          exit 1
        fi
        
        echo "‚úÖ All infrastructure resources verified successfully!"
