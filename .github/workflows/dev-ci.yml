name: Dev CI

on:
  push:
    branches: [ dev ]
  pull_request:
    branches: [ dev ]

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:

jobs:
  test-and-build:
    name: Test, Build, and Validate Dev Environment
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    services:
      localstack:
        image: localstack/localstack:3
        ports: [ "4566:4566" ]
        env:
          SERVICES: s3,sqs,dynamodb,sts
          DEBUG: 0
        options: >-
          --health-cmd="curl -s http://localhost:4566/_localstack/health"
          --health-interval=10s --health-timeout=5m --health-retries=10
    
    steps:
    # Step 0: Load shared project config
    - name: Load Project Config
      id: cfg
      uses: ./.github/actions/project-config

    # Step 1: Setup Node.js environment and run tests
    - name: Setup Node.js Environment
      uses: ./.github/actions/setup-node-environment
      with:
        node-version: ${{ steps.cfg.outputs.node-version }}
        yarn-version: ${{ steps.cfg.outputs.yarn-version }}
      
    - name: Run Tests and Build
      uses: ./.github/actions/run-tests
      with:
        node-env: test
        aws-region: ${{ steps.cfg.outputs.aws-region }}
        aws-access-key-id: ${{ steps.cfg.outputs.aws-access-key-id }}
        aws-secret-access-key: ${{ steps.cfg.outputs.aws-secret-access-key }}
        aws-endpoint: ${{ steps.cfg.outputs.aws-endpoint }}
        table-name: ${{ steps.cfg.outputs.table-name }}
        queue-name: ${{ steps.cfg.outputs.queue-name }}
        s3-bucket: ${{ steps.cfg.outputs.s3-bucket }}
        sqs-queue-url: http://sqs.${{ steps.cfg.outputs.aws-region }}.localhost.localstack.cloud:4566/000000000000/${{ steps.cfg.outputs.queue-name }}
      
    # Step 2: Start dev server with LocalStack (test integration)
    - name: Test dev server with LocalStack
      run: |
        echo "Starting dev server with LocalStack integration..."
        timeout 30s yarn start:dev &
        DEV_PID=$!
        
        # Wait for server to start
        for i in {1..30}; do
          if curl -s http://localhost:3000${{ steps.cfg.outputs.health-path-common }} > /dev/null 2>&1; then
            echo "✅ Dev server started successfully"
            break
          fi
          echo "Waiting for dev server... ($i/30)"
          sleep 2
        done
        
        # Test health endpoint
        curl -f http://localhost:3000${{ steps.cfg.outputs.health-path-common }}
        
        # Clean up
        kill $DEV_PID 2>/dev/null || true
      env:
        NODE_ENV: development-localstack
        AWS_REGION: ${{ steps.cfg.outputs.aws-region }}
        AWS_ACCESS_KEY_ID: ${{ steps.cfg.outputs.aws-access-key-id }}
        AWS_SECRET_ACCESS_KEY: ${{ steps.cfg.outputs.aws-secret-access-key }}
        AWS_ENDPOINT: ${{ steps.cfg.outputs.aws-endpoint }}
        TABLE_NAME: ${{ steps.cfg.outputs.table-name }}
        QUEUE_NAME: ${{ steps.cfg.outputs.queue-name }}
        S3_BUCKET: ${{ steps.cfg.outputs.s3-bucket }}
        SQS_QUEUE_URL: http://sqs.${{ steps.cfg.outputs.aws-region }}.localhost.localstack.cloud:4566/000000000000/${{ steps.cfg.outputs.queue-name }}
        
    # Step 3: Build and Test Docker + AWS infra
    - name: Build and Test Docker container with AWS infra
      run: |
        echo "Building Docker image for dev environment..."
        docker build -f "${{ steps.cfg.outputs.dockerfile-dev }}" -t soundbite-dev:latest .
        echo "✅ Docker image built successfully"
        
        echo "Testing Docker container with AWS infrastructure..."
        
        # Start container with proper networking for GitHub Actions
        docker run -d \
          --name test-dev-container \
          -p 3001:3000 \
          -e NODE_ENV=development-localstack \
          -e AWS_REGION=${{ steps.cfg.outputs.aws-region }} \
          -e AWS_ACCESS_KEY_ID=${{ steps.cfg.outputs.aws-access-key-id }} \
          -e AWS_SECRET_ACCESS_KEY=${{ steps.cfg.outputs.aws-secret-access-key }} \
          -e AWS_ENDPOINT=${{ steps.cfg.outputs.aws-endpoint }} \
          -e TABLE_NAME=${{ steps.cfg.outputs.table-name }} \
          -e QUEUE_NAME=${{ steps.cfg.outputs.queue-name }} \
          -e S3_BUCKET=${{ steps.cfg.outputs.s3-bucket }} \
          -e SQS_QUEUE_URL=http://sqs.${{ steps.cfg.outputs.aws-region }}.localhost.localstack.cloud:4566/000000000000/${{ steps.cfg.outputs.queue-name }} \
          soundbite-dev:latest
        
        # Wait for container to start
        for i in {1..30}; do
          if curl -s http://localhost:3001${{ steps.cfg.outputs.health-path-common }} > /dev/null 2>&1; then
            echo "✅ Docker container started successfully"
            break
          fi
          echo "Waiting for container... ($i/30)"
          sleep 2
        done
        
        # Test health endpoint
        curl -f http://localhost:3001${{ steps.cfg.outputs.health-path-common }}
        
        # Test API endpoint
        curl -f http://localhost:3001/
        
        # Clean up
        docker stop test-dev-container || true
        docker rm test-dev-container || true
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: dev-build-artifacts
        path: dist/
        retention-days: 1
