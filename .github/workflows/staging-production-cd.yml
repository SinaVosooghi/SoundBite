name: Staging/Production CD

on:
  push:
    branches: [ staging, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

permissions:
  contents: read
  id-token: write

concurrency:
  group: environment-${{ github.ref }}
  cancel-in-progress: false

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 762233763891.dkr.ecr.us-east-1.amazonaws.com
  ECR_REPOSITORY: soundbite-development-api

jobs:
  deploy:
    name: Deploy to Environment
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: |
      github.event_name == 'push' ||
      github.event_name == 'workflow_dispatch'
    
    steps:
    # Step 6: Pull image from ECR to EC2 and restart server
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Verify CI Success
      if: github.event_name == 'workflow_run'
      run: |
        echo "üîç Verifying CI completed successfully..."
        echo "CI Workflow: ${{ github.event.workflow_run.name }}"
        echo "CI Conclusion: ${{ github.event.workflow_run.conclusion }}"
        echo "CI Status: ${{ github.event.workflow_run.status }}"
        echo "‚úÖ CI has passed. Proceeding with deployment to ${{ github.event.workflow_run.head_branch }}"
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::762233763891:role/GitHubActions-SoundBite-Prod
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Determine environment
      id: env-info
      run: |
        # Determine environment based on branch
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          TAG="${{ github.event.inputs.environment }}"
        else
          BRANCH="${GITHUB_REF#refs/heads/}"
          if [[ "$BRANCH" == "master" ]]; then
            ENVIRONMENT="production"
            TAG="production"
          else
            ENVIRONMENT="staging"
            TAG="staging"
          fi
        fi
        
        if [[ "$ENVIRONMENT" == "production" ]]; then
          echo "environment=production" >> $GITHUB_OUTPUT
          echo "tag=production" >> $GITHUB_OUTPUT
          echo "node-env=production" >> $GITHUB_OUTPUT
          echo "ec2-instance-id=i-0e42eb553386cc529" >> $GITHUB_OUTPUT  # Shared instance for MVP
        else
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "tag=staging" >> $GITHUB_OUTPUT
          echo "node-env=staging" >> $GITHUB_OUTPUT
          echo "ec2-instance-id=i-0e42eb553386cc529" >> $GITHUB_OUTPUT  # Shared instance for MVP
        fi
        
    - name: Get latest image tag
      id: image-tag
      run: |
        # Get the latest image tag from ECR
        IMAGE_TAG=$(aws ecr describe-images \
          --repository-name ${{ env.ECR_REPOSITORY }} \
          --image-ids imageTag=${{ steps.env-info.outputs.tag }} \
          --query 'imageDetails[0].imageTags[0]' \
          --output text)
        echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "Using image tag: $IMAGE_TAG"
        
    - name: Deploy to EC2
      run: |
        # Set dynamic variables
        ENVIRONMENT="${{ steps.env-info.outputs.environment }}"
        IMAGE_TAG="${{ steps.image-tag.outputs.tag }}"
        NODE_ENV="${{ steps.env-info.outputs.node-env }}"
        
        # Both environments use the same internal port (3000)
        # Nginx handles routing based on URL path (/staging, /production)
        APP_PORT=3000
        
        # Set external port mapping to avoid conflicts
        # Production is already using 3001, so staging uses 3002
        if [[ "$ENVIRONMENT" == "staging" ]]; then
          EXTERNAL_PORT=3002
        else
          EXTERNAL_PORT=3001
        fi
        
        echo "üöÄ Starting deployment for $ENVIRONMENT..."
        echo "üì¶ Image: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"
        echo "üåê Port: $APP_PORT"
        
        # Check if staging resources exist before deployment
        if [[ "$ENVIRONMENT" == "staging" ]]; then
          echo "üîç Checking staging resources..."
          # Check if staging table exists
          if ! aws dynamodb describe-table --table-name SoundBite-staging-SoundbitesTable --region us-east-1 >/dev/null 2>&1; then
            echo "‚ùå Staging table does not exist. Please deploy staging infrastructure first."
            exit 1
          fi
          # Check if staging S3 bucket exists
          if ! aws s3 ls s3://soundbite-staging-soundbites-762233763891/ --region us-east-1 >/dev/null 2>&1; then
            echo "‚ùå Staging S3 bucket does not exist. Please deploy staging infrastructure first."
            exit 1
          fi
          echo "‚úÖ Staging resources verified"
        fi

        # Execute deployment commands directly on EC2
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids ${{ steps.env-info.outputs.ec2-instance-id }} \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[
            \"echo \\\"üöÄ Starting deployment for $ENVIRONMENT...\\\"\",
            \"aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}\",
            \"echo \\\"üì¶ Pulling latest image...\\\"\",
            \"docker pull ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG\",
            \"echo \\\"üõë Stopping existing container...\\\"\",
            \"docker stop soundbite-$ENVIRONMENT || true\",
            \"docker rm soundbite-$ENVIRONMENT || true\",
            \"echo \\\"üßπ Cleaning up Docker to free space...\\\"\",
            \"docker system prune -f || true\",
            \"echo \\\"‚ñ∂Ô∏è Starting new container...\\\"\",
            \"# Use environment-specific resources as per CDK stack pattern\",
            \"if [[ \\\"$ENVIRONMENT\\\" == \\\"staging\\\" ]]; then\",
            \"  echo \\\"Using staging resources\\\"\",
            \"  docker run -d --name soundbite-$ENVIRONMENT --restart unless-stopped -p $EXTERNAL_PORT:3000 -e NODE_ENV=$NODE_ENV -e ENVIRONMENT=$ENVIRONMENT -e AWS_REGION=us-east-1 -e TABLE_NAME=SoundBite-staging-SoundbitesTable -e QUEUE_NAME=SoundBite-MultiEnv-SoundbiteQueue -e S3_BUCKET=soundbite-staging-soundbites-762233763891 -e SQS_QUEUE_URL=https://sqs.us-east-1.amazonaws.com/762233763891/SoundBite-MultiEnv-SoundbiteQueue ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG\",
            \"else\",
            \"  echo \\\"Using development resources\\\"\",
            \"  docker run -d --name soundbite-$ENVIRONMENT --restart unless-stopped -p $EXTERNAL_PORT:3000 -e NODE_ENV=$NODE_ENV -e ENVIRONMENT=$ENVIRONMENT -e AWS_REGION=us-east-1 -e TABLE_NAME=SoundBite-development-SoundbitesTable -e QUEUE_NAME=SoundBite-MultiEnv-SoundbiteQueue -e S3_BUCKET=soundbite-development-soundbites-762233763891 -e SQS_QUEUE_URL=https://sqs.us-east-1.amazonaws.com/762233763891/SoundBite-MultiEnv-SoundbiteQueue ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG\",
            \"fi\",
            \"echo \\\"‚è≥ Waiting for health check...\\\"\",
            \"for i in {1..30}; do if curl -s http://localhost:$EXTERNAL_PORT/health > /dev/null 2>&1; then echo \\\"‚úÖ Deployment successful!\\\"; break; fi; echo \\\"Waiting for health check... (\\\$i/30)\\\"; sleep 2; done\",
            \"echo \\\"üßπ Cleaning up old images...\\\"\",
            \"docker image prune -f\",
            \"echo \\\"üîß Updating Nginx configuration...\\\"\",
            \"sed -i \\\"s|proxy_pass http://localhost:3000/;|proxy_pass http://localhost:3002/;|g\\\" /etc/nginx/conf.d/soundbite.conf\",
            \"nginx -t && systemctl reload nginx\",
            \"echo \\\"üéâ Deployment completed!\\\"\"
          ]" \
          --region ${{ env.AWS_REGION }} \
          --query 'Command.CommandId' \
          --output text)
        
        echo "Command ID: $COMMAND_ID"
        
        # Wait for command to complete
        echo "‚è≥ Waiting for deployment to complete..."
        aws ssm wait command-executed \
          --command-id $COMMAND_ID \
          --instance-id ${{ steps.env-info.outputs.ec2-instance-id }} \
          --region ${{ env.AWS_REGION }}
        
        # Check command status
        aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ steps.env-info.outputs.ec2-instance-id }} \
          --region ${{ env.AWS_REGION }}
        
        # Alternative: Use SSH if SSM is not available
        # ssh -o StrictHostKeyChecking=no ubuntu@$EC2_IP 'bash -s' < deploy.sh
        
    - name: Verify deployment
      run: |
        echo "üîç Verifying deployment..."
        
        # Get EC2 instance public IP
        EC2_IP=$(aws ec2 describe-instances \
          --instance-ids ${{ steps.env-info.outputs.ec2-instance-id }} \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "EC2 Public IP: $EC2_IP"
        
        # Determine port based on environment
        if [[ "${{ steps.env-info.outputs.environment }}" == "staging" ]]; then
          APP_PORT=3001
        else
          APP_PORT=3000
        fi
        
        # Test health endpoint
        for i in {1..10}; do
          if curl -s http://$EC2_IP:$APP_PORT/health > /dev/null 2>&1; then
            echo "‚úÖ Health check passed!"
            break
          fi
          echo "Waiting for health check... ($i/10)"
          sleep 10
        done
        
        # Test API endpoint
        curl -f http://$EC2_IP:$APP_PORT/health
        echo "‚úÖ API endpoint is responding!"
        
    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ ${{ steps.env-info.outputs.environment }} deployment successful!"
        else
          echo "‚ùå ${{ steps.env-info.outputs.environment }} deployment failed!"
        fi
