name: Staging/Production CD

on:
  workflow_run:
    workflows: ["Staging/Production CI"]
    types: [completed]
    branches: [ staging, master ]

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 762233763891.dkr.ecr.us-east-1.amazonaws.com
  ECR_REPOSITORY: soundbite-development-api

jobs:
  deploy:
    name: Deploy to Environment
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: |
      github.event_name == 'push' || 
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    
    steps:
    # Step 6: Pull image from ECR to EC2 and restart server
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::762233763891:role/GitHubActions-SoundBite-Prod
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Determine environment
      id: env-info
      run: |
        if [[ "${{ github.event.workflow_run.head_branch }}" == "master" ]]; then
          echo "environment=production" >> $GITHUB_OUTPUT
          echo "tag=production" >> $GITHUB_OUTPUT
          echo "ec2-instance-id=i-0e42eb553386cc529" >> $GITHUB_OUTPUT  # Shared instance for MVP
        elif [[ "${{ github.event.workflow_run.head_branch }}" == "staging" ]]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "tag=staging" >> $GITHUB_OUTPUT
          echo "ec2-instance-id=i-0e42eb553386cc529" >> $GITHUB_OUTPUT  # Shared instance for MVP
        else
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "tag=staging" >> $GITHUB_OUTPUT
          echo "ec2-instance-id=i-0e42eb553386cc529" >> $GITHUB_OUTPUT  # Shared instance for MVP
        fi
        
    - name: Get latest image tag
      id: image-tag
      run: |
        # Get the latest image tag from ECR
        IMAGE_TAG=$(aws ecr describe-images \
          --repository-name ${{ env.ECR_REPOSITORY }} \
          --image-ids imageTag=${{ steps.env-info.outputs.tag }} \
          --query 'imageDetails[0].imageTags[0]' \
          --output text)
        echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "Using image tag: $IMAGE_TAG"
        
    - name: Deploy to EC2
      run: |
        echo "Deploying ${{ steps.env-info.outputs.environment }} to EC2..."
        
        # Create deployment script
        cat > deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "üöÄ Starting deployment..."
        
        # Login to ECR
        aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY
        
        # Pull latest image
        echo "üì¶ Pulling latest image..."
        docker pull $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        # Stop existing container
        echo "üõë Stopping existing container..."
        docker stop soundbite-$ENVIRONMENT || true
        docker rm soundbite-$ENVIRONMENT || true
        
        # Start new container
        echo "‚ñ∂Ô∏è Starting new container..."
        if [[ "$ENVIRONMENT" == "staging" ]]; then
          APP_PORT=3001
        else
          APP_PORT=3000
        fi
        
        docker run -d \
          --name soundbite-$ENVIRONMENT \
          --restart unless-stopped \
          -p $APP_PORT:3000 \
          -e NODE_ENV=$ENVIRONMENT \
          -e AWS_REGION=$AWS_REGION \
          -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
          -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
          -e TABLE_NAME=SoundbitesTable \
          -e QUEUE_NAME=SoundbiteQueue \
          -e S3_BUCKET=soundbitesbucket \
          -e SQS_QUEUE_URL=https://sqs.us-east-1.amazonaws.com/762233763891/SoundbiteQueue \
          $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        # Wait for health check
        echo "‚è≥ Waiting for health check..."
        for i in {1..30}; do
          if curl -s http://localhost:$APP_PORT/health > /dev/null 2>&1; then
            echo "‚úÖ Deployment successful!"
            break
          fi
          echo "Waiting for health check... ($i/30)"
          sleep 2
        done
        
        # Clean up old images
        echo "üßπ Cleaning up old images..."
        docker image prune -f
        
        echo "üéâ Deployment completed!"
        EOF
        
        # Make script executable
        chmod +x deploy.sh
        
        # Execute deployment on EC2
        echo "üì§ Executing deployment on EC2..."
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids ${{ steps.env-info.outputs.ec2-instance-id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=["bash -s"]' \
          --region ${{ env.AWS_REGION }} \
          --query 'Command.CommandId' \
          --output text)
        
        echo "Command ID: $COMMAND_ID"
        
        # Wait for command to complete
        echo "‚è≥ Waiting for deployment to complete..."
        aws ssm wait command-executed \
          --command-id $COMMAND_ID \
          --instance-id ${{ steps.env-info.outputs.ec2-instance-id }} \
          --region ${{ env.AWS_REGION }}
        
        # Check command status
        aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ steps.env-info.outputs.ec2-instance-id }} \
          --region ${{ env.AWS_REGION }}
        
        # Alternative: Use SSH if SSM is not available
        # ssh -o StrictHostKeyChecking=no ubuntu@$EC2_IP 'bash -s' < deploy.sh
        
    - name: Verify deployment
      run: |
        echo "üîç Verifying deployment..."
        
        # Get EC2 instance public IP
        EC2_IP=$(aws ec2 describe-instances \
          --instance-ids ${{ steps.env-info.outputs.ec2-instance-id }} \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "EC2 Public IP: $EC2_IP"
        
        # Determine port based on environment
        if [[ "${{ steps.env-info.outputs.environment }}" == "staging" ]]; then
          APP_PORT=3001
        else
          APP_PORT=3000
        fi
        
        # Test health endpoint
        for i in {1..10}; do
          if curl -s http://$EC2_IP:$APP_PORT/health > /dev/null 2>&1; then
            echo "‚úÖ Health check passed!"
            break
          fi
          echo "Waiting for health check... ($i/10)"
          sleep 10
        done
        
        # Test API endpoint
        curl -f http://$EC2_IP:$APP_PORT/health
        echo "‚úÖ API endpoint is responding!"
        
    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ ${{ steps.env-info.outputs.environment }} deployment successful!"
        else
          echo "‚ùå ${{ steps.env-info.outputs.environment }} deployment failed!"
        fi
