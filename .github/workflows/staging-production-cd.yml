name: Staging/Production CD

on:
  push:
    branches: [ staging, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

permissions:
  contents: read
  id-token: write

concurrency:
  group: environment-${{ github.ref }}
  cancel-in-progress: false

jobs:
  deploy:
    name: Deploy to Environment
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: true
    
    steps:
    # Step 6: Pull image from ECR to EC2 and restart server
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Load Project Config
      id: cfg
      uses: ./.github/actions/project-config

    - name: Verify CI Success
      if: github.event_name == 'push'
      run: |
        echo "🔍 Verifying CI completed successfully..."
        echo "Branch: ${{ github.ref_name }}"
        echo "✅ Proceeding with deployment to ${{ github.ref_name }}"
      
    - name: Configure AWS credentials
      uses: ./.github/actions/configure-aws
      with:
        role-to-assume: ${{ steps.cfg.outputs.role-to-assume }}
        aws-region: ${{ steps.cfg.outputs.aws-region }}
        
    - name: Determine environment
      id: env-info
      uses: ./.github/actions/determine-environment
      with:
        default-ec2-instance-id: ${{ steps.cfg.outputs.default-ec2-instance-id }}
        
    - name: Resolve target EC2 instance by environment
      id: target-ec2
      run: |
        set -euo pipefail
        ENV="${{ steps.env-info.outputs.environment }}"
        STACK_NAME="SoundBite-$ENV-API"
        echo "Resolving EC2 instance for stack: $STACK_NAME"
        INSTANCE_ID=$(aws cloudformation describe-stacks \
          --stack-name "$STACK_NAME" \
          --query "Stacks[0].Outputs[?OutputKey=='ApiInstanceId'].OutputValue" \
          --output text 2>/dev/null || true)
        if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "N/A" ]; then
          INSTANCE_ID="${{ steps.env-info.outputs.ec2-instance-id }}"
          echo "Falling back to default instance id: $INSTANCE_ID"
        fi
        echo "instance-id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        
    - name: Build and push Docker image
      id: image-tag
      uses: ./.github/actions/docker-build-push
      with:
        dockerfile: ${{ steps.cfg.outputs.dockerfile-prod }}
        image-name: soundbite-${{ steps.env-info.outputs.tag }}
        ecr-registry: ${{ steps.cfg.outputs.ecr-registry }}
        ecr-repository: ${{ steps.cfg.outputs.ecr-repository }}
        tag: ${{ steps.env-info.outputs.tag }}
        aws-region: ${{ steps.cfg.outputs.aws-region }}
        
    - name: Ensure Docker Compose files on EC2
      run: |
        # Ensure Docker Compose files exist on EC2 (should be deployed with repo)
        echo "Docker Compose files should be available on EC2 at /home/ec2-user/"
    
    - name: Deploy to EC2 via SSM and Docker Compose
      id: deploy
      uses: ./.github/actions/deploy-ssm-compose
      with:
        instance-id: ${{ steps.target-ec2.outputs.instance-id }}
        environment: ${{ steps.env-info.outputs.environment }}
        ecr-registry: ${{ steps.cfg.outputs.ecr-registry }}
        ecr-repository: ${{ steps.cfg.outputs.ecr-repository }}
        image-tag: ${{ steps.env-info.outputs.tag }}
        aws-region: ${{ steps.cfg.outputs.aws-region }}
        
        # Alternative: Use SSH if SSM is not available
        # ssh -o StrictHostKeyChecking=no ubuntu@$EC2_IP 'bash -s' < deploy.sh
    
    - name: "Diagnostics (SSM): docker-compose status and logs"
      env:
        ENV: ${{ steps.env-info.outputs.environment }}
        IID: ${{ steps.target-ec2.outputs.instance-id }}
        REGION: ${{ steps.cfg.outputs.aws-region }}
      run: |
        set -uo pipefail
        echo "Running diagnostics on $IID in $REGION for $ENV..."
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$IID" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[
            \"set -euo pipefail\",
            \"echo ==== docker ps -a ====\",
            \"docker ps -a\",
            \"echo ==== docker-compose ps ====\",
            \"docker-compose -f /home/ec2-user/docker-compose.ec2.yml ps || true\",
            \"echo ==== nginx logs tail 200 ====\",
            \"docker-compose -f /home/ec2-user/docker-compose.ec2.yml logs --tail=200 nginx || true\",
            \"echo ==== service logs tail 200 ====\",
            \"docker-compose -f /home/ec2-user/docker-compose.ec2.yml logs --tail=200 soundbite-$ENV || true\",
            \"echo ==== listening sockets on 8080 ====\",
            \"sudo ss -ltnp | grep 8080 || true\",
            \"echo ==== local curls ====\",
            \"curl -fsS http://localhost:8080/health || true\",
            \"curl -fsS http://localhost:8080/$ENV/health || true\"
          ]" \
          --region "$REGION" \
          --query 'Command.CommandId' \
          --output text)
        echo "Command ID: $COMMAND_ID"
        # Poll status manually to avoid failing the workflow on non-success
        for i in $(seq 1 30); do
          STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$IID" --region "$REGION" --query Status --output text || echo "Unknown")
          echo "SSM status: $STATUS"
          case "$STATUS" in
            Success|Failed|Cancelled|TimedOut)
              break
              ;;
            *)
              sleep 2
              ;;
          esac
        done
        aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$IID" --region "$REGION" || true
        
    - name: Verify deployment endpoints (env-aware)
      uses: ./.github/actions/verify-endpoints
      with:
        instance-id: ${{ steps.target-ec2.outputs.instance-id }}
        aws-region: ${{ steps.cfg.outputs.aws-region }}
        check-paths: |
          ${{ steps.env-info.outputs.environment == 'production' && steps.cfg.outputs.health-path-prod || steps.cfg.outputs.health-path-staging }}
        
    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "✅ ${{ steps.env-info.outputs.environment }} deployment successful!"
        else
          echo "❌ ${{ steps.env-info.outputs.environment }} deployment failed!"
        fi
