name: Staging/Production CD

on:
  push:
    branches: [ staging, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

permissions:
  contents: read
  id-token: write

concurrency:
  group: environment-${{ github.ref }}
  cancel-in-progress: false

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 762233763891.dkr.ecr.us-east-1.amazonaws.com
  ECR_REPOSITORY: soundbite-development-api
  DOCKER_PROD_FILE: ./Dockerfile

jobs:
  deploy:
    name: Deploy to Environment
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: |
      github.event_name == 'push' ||
      github.event_name == 'workflow_dispatch'
    
    steps:
    # Step 6: Pull image from ECR to EC2 and restart server
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Verify CI Success
      if: github.event_name == 'push'
      run: |
        echo "üîç Verifying CI completed successfully..."
        echo "Branch: ${{ github.ref_name }}"
        echo "‚úÖ Proceeding with deployment to ${{ github.ref_name }}"
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::762233763891:role/GitHubActions-SoundBite-Prod
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Determine environment
      id: env-info
      run: |
        # Determine environment based on branch
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          TAG="${{ github.event.inputs.environment }}"
        else
          BRANCH="${GITHUB_REF#refs/heads/}"
          if [[ "$BRANCH" == "master" ]]; then
            ENVIRONMENT="production"
            TAG="production"
          else
            ENVIRONMENT="staging"
            TAG="staging"
          fi
        fi
        
        if [[ "$ENVIRONMENT" == "production" ]]; then
          echo "environment=production" >> $GITHUB_OUTPUT
          echo "tag=production" >> $GITHUB_OUTPUT
          echo "node-env=production" >> $GITHUB_OUTPUT
          echo "ec2-instance-id=i-0e42eb553386cc529" >> $GITHUB_OUTPUT  # Shared instance for MVP
        else
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "tag=staging" >> $GITHUB_OUTPUT
          echo "node-env=staging" >> $GITHUB_OUTPUT
          echo "ec2-instance-id=i-0e42eb553386cc529" >> $GITHUB_OUTPUT  # Shared instance for MVP
        fi
        
    - name: Get latest image tag
      id: image-tag
      run: |
        # Build a fresh image and tag to branch tag
        echo "Building Docker image for ${{ steps.env-info.outputs.tag }}..."
        docker build -f ${{ env.DOCKER_PROD_FILE:-./Dockerfile }} -t soundbite-${{ steps.env-info.outputs.tag }}:latest .
        echo "Logging in to ECR..."
        aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}
        echo "Tagging image for ECR..."
        docker tag soundbite-${{ steps.env-info.outputs.tag }}:latest ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.env-info.outputs.tag }}
        echo "Pushing image to ECR..."
        docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.env-info.outputs.tag }}
        echo "tag=${{ steps.env-info.outputs.tag }}" >> $GITHUB_OUTPUT
        echo "Using image tag: ${{ steps.env-info.outputs.tag }}"
        
    - name: Ensure Docker Compose files on EC2
      run: |
        # Ensure Docker Compose files exist on EC2 (should be deployed with repo)
        echo "Docker Compose files should be available on EC2 at /home/ec2-user/"
    
    - name: Deploy to EC2
      run: |
        # Set dynamic variables
        ENVIRONMENT="${{ steps.env-info.outputs.environment }}"
        IMAGE_TAG="${{ steps.image-tag.outputs.tag }}"
        NODE_ENV="${{ steps.env-info.outputs.node-env }}"
        
        # Both environments use the same internal port (3000)
        # Nginx handles routing based on URL path (/staging, /production)
        APP_PORT=3000
        
        # Set external port mapping to avoid conflicts
        # Production is already using 3001, so staging uses 3002
        if [[ "$ENVIRONMENT" == "staging" ]]; then
          EXTERNAL_PORT=3002
        else
          EXTERNAL_PORT=3001
        fi
        
        echo "üöÄ Starting deployment for $ENVIRONMENT..."
        echo "üì¶ Image: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"
        echo "üåê Port: $APP_PORT"
        
        # Check if staging resources exist before deployment
        if [[ "$ENVIRONMENT" == "staging" ]]; then
          echo "üîç Checking staging resources..."
          # Check if staging table exists
          if ! aws dynamodb describe-table --table-name SoundBite-staging-SoundbitesTable --region us-east-1 >/dev/null 2>&1; then
            echo "‚ùå Staging table does not exist. Please deploy staging infrastructure first."
            exit 1
          fi
          # Check if staging S3 bucket exists
          if ! aws s3 ls s3://soundbite-staging-soundbites-762233763891/ --region us-east-1 >/dev/null 2>&1; then
            echo "‚ùå Staging S3 bucket does not exist. Please deploy staging infrastructure first."
            exit 1
          fi
          echo "‚úÖ Staging resources verified"
        fi

        # Deploy using Docker Compose on EC2
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids ${{ steps.env-info.outputs.ec2-instance-id }} \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[
            \"echo \\\"üöÄ Starting Docker Compose deployment for $ENVIRONMENT...\\\"\",
            \"cd /home/ec2-user\",
            \"aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}\",
            \"echo \\\"‚úçÔ∏è  Writing .env for compose with resolved tags...\\\"\",
            \"echo ECR_REGISTRY=${{ env.ECR_REGISTRY }} > .env\",
            \"echo ECR_REPOSITORY=${{ env.ECR_REPOSITORY }} >> .env\",
            \"if [[ \\\"$ENVIRONMENT\\\" == \\\"staging\\\" ]]; then echo STAGING_TAG=$IMAGE_TAG >> .env; else echo PRODUCTION_TAG=$IMAGE_TAG >> .env; fi\",
            \"echo \\\"üì¶ Pulling latest image for target service...\\\"\",
            \"if [[ \\\"$ENVIRONMENT\\\" == \\\"staging\\\" ]]; then docker-compose -f docker-compose.ec2.yml pull soundbite-staging; else docker-compose -f docker-compose.ec2.yml pull soundbite-production; fi\",
            \"echo \\\"üõë Stopping existing services...\\\"\",
            \"if [[ \\\"$ENVIRONMENT\\\" == \\\"staging\\\" ]]; then docker-compose -f docker-compose.ec2.yml stop soundbite-staging || true; else docker-compose -f docker-compose.ec2.yml stop soundbite-production || true; fi\",
            \"echo \\\"üßπ Cleaning up Docker to free space...\\\"\",
            \"docker system prune -f || true\",
            \"echo \\\"üöÄ Starting target service with Docker Compose...\\\"\",
            \"if [[ \\\"$ENVIRONMENT\\\" == \\\"staging\\\" ]]; then docker-compose -f docker-compose.ec2.yml up -d soundbite-staging nginx; else docker-compose -f docker-compose.ec2.yml up -d soundbite-production nginx; fi\",
            \"echo \\\"‚è≥ Waiting for health checks...\\\"\",
            \"sleep 30\",
            \"echo \\\"üîç Checking service status...\\\"\",
            \"docker-compose -f docker-compose.ec2.yml ps | cat\",
            \"echo \\\"‚úÖ Testing endpoints...\\\"\",
            \"curl -f http://localhost:8080/health && echo \\\"‚úÖ Nginx health OK\\\"\",
            \"curl -f http://localhost:8080/staging/health && echo \\\"‚úÖ Staging health OK\\\"\",
            \"echo \\\"üéâ Docker Compose deployment completed!\\\"\"
          ]" \
          --region ${{ env.AWS_REGION }} \
          --query 'Command.CommandId' \
          --output text)
        
        echo "Command ID: $COMMAND_ID"
        
        # Wait for command to complete
        echo "‚è≥ Waiting for deployment to complete..."
        aws ssm wait command-executed \
          --command-id $COMMAND_ID \
          --instance-id ${{ steps.env-info.outputs.ec2-instance-id }} \
          --region ${{ env.AWS_REGION }}
        
        # Check command status
        aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ steps.env-info.outputs.ec2-instance-id }} \
          --region ${{ env.AWS_REGION }}
        
        # Alternative: Use SSH if SSM is not available
        # ssh -o StrictHostKeyChecking=no ubuntu@$EC2_IP 'bash -s' < deploy.sh
        
    - name: Verify deployment
      run: |
        echo "üîç Verifying deployment..."
        
        # Get EC2 instance public IP
        EC2_IP=$(aws ec2 describe-instances \
          --instance-ids ${{ steps.env-info.outputs.ec2-instance-id }} \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "EC2 Public IP: $EC2_IP"
        
        # Test Docker Compose endpoints
        echo "Testing Docker Compose endpoints..."
        
        # Test Nginx ingress health
        curl -f http://$EC2_IP:8080/health && echo "‚úÖ Nginx ingress OK"
        
        # Test staging health
        curl -f http://$EC2_IP:8080/staging/health && echo "‚úÖ Staging API OK"
        
        # Test staging TTS API
        curl -sS -X POST http://$EC2_IP:8080/staging/soundbite \
          -H "Content-Type: application/json" \
          -H "Idempotency-Key: 550e8400-e29b-41d4-a716-446655440099" \
          -d '{"text":"CD deployment test","voiceId":"Joanna"}' \
          && echo "‚úÖ Staging TTS API OK"
        
    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ ${{ steps.env-info.outputs.environment }} deployment successful!"
        else
          echo "‚ùå ${{ steps.env-info.outputs.environment }} deployment failed!"
        fi
