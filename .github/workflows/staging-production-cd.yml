name: Staging/Production CD

on:
  push:
    branches: [ staging, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

permissions:
  contents: read
  id-token: write

concurrency:
  group: environment-${{ github.ref }}
  cancel-in-progress: false

jobs:
  deploy:
    name: Deploy to Environment
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: true
    
    steps:
    # Step 6: Pull image from ECR to EC2 and restart server
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Load Project Config
      id: cfg
      uses: ./.github/actions/project-config

    - name: Verify CI Success
      if: github.event_name == 'push'
      run: |
        echo "üîç Verifying CI completed successfully..."
        echo "Branch: ${{ github.ref_name }}"
        echo "‚úÖ Proceeding with deployment to ${{ github.ref_name }}"
      
    - name: Configure AWS credentials
      uses: ./.github/actions/configure-aws
      with:
        role-to-assume: ${{ steps.cfg.outputs.role-to-assume }}
        aws-region: ${{ steps.cfg.outputs.aws-region }}
        
    - name: Determine environment
      id: env-info
      uses: ./.github/actions/determine-environment
      with:
        default-ec2-instance-id: ${{ steps.cfg.outputs.default-ec2-instance-id }}
        
    - name: Deploy infrastructure
      id: infra-deploy
      uses: ./.github/actions/deploy-infrastructure
      with:
        environment: ${{ steps.env-info.outputs.environment }}
        aws-region: ${{ steps.cfg.outputs.aws-region }}
        deployment-strategy: 'individual'
        require-approval: 'never'
        default-ec2-instance-id: ${{ steps.cfg.outputs.default-ec2-instance-id }}
        
    - name: Resolve target EC2 instance by environment
      id: target-ec2
      run: |
        set -euo pipefail
        ENV="${{ steps.env-info.outputs.environment }}"
        
        # Determine the correct prefix based on environment
        if [ "$ENV" = "production" ]; then
          PREFIX="prod"
        elif [ "$ENV" = "staging" ]; then
          PREFIX="staging"
        else
          PREFIX="$ENV"
        fi
        
        STACK_NAME="SoundBite-$PREFIX-API"
        echo "Resolving EC2 instance for stack: $STACK_NAME (environment: $ENV, prefix: $PREFIX)"
        
        # Try to get instance ID from infrastructure deployment outputs first
        if [ -f "deployment-outputs.json" ]; then
          INSTANCE_ID=$(jq -r ".\"$STACK_NAME\".ApiInstanceId // empty" deployment-outputs.json 2>/dev/null || true)
          if [ -n "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "null" ]; then
            echo "Found instance ID from deployment outputs: $INSTANCE_ID"
          fi
        fi
        
        # Fallback to CloudFormation query
        if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "null" ]; then
          INSTANCE_ID=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].Outputs[?OutputKey=='ApiInstanceId'].OutputValue" \
            --output text 2>/dev/null || true)
        fi
        
        # Final fallback to default
        if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "N/A" ]; then
          INSTANCE_ID="${{ steps.env-info.outputs.ec2-instance-id }}"
          echo "Falling back to default instance id: $INSTANCE_ID"
        fi
        
        echo "instance-id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        
    - name: Verify infrastructure deployment
      run: |
        set -euo pipefail
        ENV="${{ steps.env-info.outputs.environment }}"
        
        echo "üîç Verifying infrastructure deployment for $ENV..."
        
        # Check if infrastructure deployment was successful
        if [ "${{ steps.infra-deploy.outputs.deployment-status }}" != "success" ]; then
          echo "‚ùå Infrastructure deployment failed"
          exit 1
        fi
        
        echo "‚úÖ Infrastructure deployment verified successfully"
        
    - name: Build and push Docker image
      id: image-tag
      uses: ./.github/actions/docker-build-push
      with:
        dockerfile: ${{ steps.cfg.outputs.dockerfile-prod }}
        image-name: soundbite-${{ steps.env-info.outputs.tag }}
        ecr-registry: ${{ vars.ECR_REGISTRY || steps.cfg.outputs.ecr-registry }}
        ecr-repository: ${{ vars.ECR_REPOSITORY || steps.cfg.outputs.ecr-repository }}
        tag: ${{ steps.env-info.outputs.tag }}
        aws-region: ${{ steps.cfg.outputs.aws-region }}
        
    - name: Ensure Docker Compose files on EC2
      run: |
        # Ensure Docker Compose files exist on EC2 (should be deployed with repo)
        echo "Docker Compose files should be available on EC2 at /home/ec2-user/"
    
    - name: Deploy to EC2 via SSM and Docker Compose
      id: deploy
      uses: ./.github/actions/deploy-ssm-compose
      with:
        instance-id: ${{ steps.target-ec2.outputs.instance-id }}
        environment: ${{ steps.env-info.outputs.environment }}
        ecr-registry: ${{ vars.ECR_REGISTRY || steps.cfg.outputs.ecr-registry }}
        ecr-repository: ${{ vars.ECR_REPOSITORY || steps.cfg.outputs.ecr-repository }}
        image-tag: ${{ steps.env-info.outputs.tag }}
        aws-region: ${{ steps.cfg.outputs.aws-region }}
        
        # Alternative: Use SSH if SSM is not available
        # ssh -o StrictHostKeyChecking=no ubuntu@$EC2_IP 'bash -s' < deploy.sh
    
    - name: "Diagnostics (SSM): docker-compose status and logs"
      env:
        ENV: ${{ steps.env-info.outputs.environment }}
        IID: ${{ steps.target-ec2.outputs.instance-id }}
        REGION: ${{ steps.cfg.outputs.aws-region }}
      run: |
        set -uo pipefail
        echo "Running diagnostics on $IID in $REGION for $ENV..."
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$IID" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[
            \"set -euo pipefail\",
            \"echo ==== docker ps -a ====\",
            \"docker ps -a\",
            \"echo ==== docker-compose ps ====\",
            \"docker-compose -f /home/ec2-user/docker-compose.ec2.yml ps || true\",
            \"echo ==== docker inspect ports: nginx ====\",
            \"docker inspect --format='{{json .NetworkSettings.Ports}}' soundbite-nginx | jq . || true\",
            \"echo ==== docker inspect ports: service ====\",
            \"docker inspect --format='{{json .NetworkSettings.Ports}}' soundbite-$ENV | jq . || true\",
            \"echo ==== nginx logs tail 200 ====\",
            \"docker-compose -f /home/ec2-user/docker-compose.ec2.yml logs --tail=200 nginx || true\",
            \"echo ==== service logs tail 200 ====\",
            \"docker-compose -f /home/ec2-user/docker-compose.ec2.yml logs --tail=200 soundbite-$ENV || true\",
            \"echo ==== listening sockets on 8080 ====\",
            \"sudo ss -ltnp | grep 8080 || true\",
            \"echo ==== local curls ====\",
            \"curl -fsS http://localhost:8080/health || true\",
            \"curl -fsS http://localhost:8080/$ENV/health || true\"
          ]" \
          --region "$REGION" \
          --query 'Command.CommandId' \
          --output text)
        echo "Command ID: $COMMAND_ID"
        # Poll status manually to avoid failing the workflow on non-success
        for i in $(seq 1 30); do
          STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$IID" --region "$REGION" --query Status --output text || echo "Unknown")
          echo "SSM status: $STATUS"
          case "$STATUS" in
            Success|Failed|Cancelled|TimedOut)
              break
              ;;
            *)
              sleep 2
              ;;
          esac
        done
        aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$IID" --region "$REGION" || true
        
    - name: Verify deployment endpoints (env-aware)
      uses: ./.github/actions/verify-endpoints
      with:
        instance-id: ${{ steps.target-ec2.outputs.instance-id }}
        aws-region: ${{ steps.cfg.outputs.aws-region }}
        check-paths: |
          ${{ steps.env-info.outputs.environment == 'production' && steps.cfg.outputs.health-path-prod || steps.cfg.outputs.health-path-staging }}

    - name: Canary check (staging only)
      if: ${{ steps.env-info.outputs.environment == 'staging' }}
      run: |
        set -euo pipefail
        EC2_IP=$(aws ec2 describe-instances \
          --instance-ids ${{ steps.target-ec2.outputs.instance-id }} \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "üß™ Running canary test for staging environment..."
        
        # Test API endpoint
        RESPONSE=$(curl -sS -X POST http://$EC2_IP/staging/soundbite \
          -H "Content-Type: application/json" \
          -H "Idempotency-Key: 550e8400-e29b-41d4-a716-446655440000" \
          -d '{"text":"staging canary","voiceId":"Joanna"}' || true)
        
        echo "API Response: $RESPONSE"
        
        # Extract soundbite ID from response
        SOUNDBITE_ID=$(echo "$RESPONSE" | jq -r '.id // empty' 2>/dev/null || true)
        
        if [ -n "$SOUNDBITE_ID" ]; then
          echo "‚úÖ Canary test created soundbite: $SOUNDBITE_ID"
          
          # Wait a bit for Lambda processing
          echo "‚è≥ Waiting for Lambda processing..."
          sleep 10
          
          # Check if soundbite was processed
          STATUS_RESPONSE=$(curl -sS http://$EC2_IP/staging/soundbite/$SOUNDBITE_ID || true)
          STATUS=$(echo "$STATUS_RESPONSE" | jq -r '.status // empty' 2>/dev/null || true)
          
          echo "Soundbite status: $STATUS"
          
          if [ "$STATUS" = "ready" ]; then
            echo "‚úÖ Lambda processing successful - soundbite is ready!"
          else
            echo "‚ö†Ô∏è Lambda processing may still be in progress (status: $STATUS)"
          fi
        else
          echo "‚ùå Canary test failed - no soundbite ID returned"
          exit 1
        fi
        
    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ ${{ steps.env-info.outputs.environment }} deployment successful!"
        else
          echo "‚ùå ${{ steps.env-info.outputs.environment }} deployment failed!"
        fi
