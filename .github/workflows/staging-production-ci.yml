name: Staging/Production CI

# This workflow handles CI for staging and production environments:
# - Runs unit tests (no LocalStack - uses real AWS services)
# - Builds and tests production Docker containers
# - Pushes production images to ECR (staging branch only)
# - Supports both direct pushes and pull requests

on:
  push:
    branches: [ staging, master ]
  pull_request:
    branches: [ staging, master ]
    types: [ opened, synchronize, reopened ]

permissions:
  contents: read
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  # Node.js Configuration
  NODE_VERSION: '22'
  YARN_VERSION: '4.9.4'
  
  # AWS Configuration
  AWS_REGION: us-east-1
  AWS_ACCOUNT_ID: 762233763891
  ECR_REGISTRY: 762233763891.dkr.ecr.us-east-1.amazonaws.com
  ECR_REPOSITORY: soundbite-development-api
  
  # AWS Service Configuration
  TABLE_NAME: SoundbitesTable
  QUEUE_NAME: SoundbiteQueue
  S3_BUCKET: soundbitesbucket
  
  
  # Docker Configuration
  DOCKER_PROD_FILE: ./Dockerfile
  CONTAINER_PORT: 3001
  HEALTH_CHECK_PORT: 3001
  
  # AWS IAM Configuration
  AWS_ROLE_NAME: GitHubActions-SoundBite-Prod
  
  # Test Configuration
  TEST_TIMEOUT: 30
  HEALTH_CHECK_TIMEOUT: 30

jobs:
  test-and-push:
    name: Test, Build, and Push to ECR
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # Only run on staging/master branches or PRs targeting them
    # Skip if PR is from dev to master (should go through staging first)
    if: |
      github.ref == 'refs/heads/staging' || 
      github.ref == 'refs/heads/master' || 
      (github.event_name == 'pull_request' && 
       (github.base_ref == 'staging' || github.base_ref == 'master') &&
       !(github.head_ref == 'dev' && github.base_ref == 'master'))
    
    
    steps:
    # Step 1: Lint, unit test, build
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'yarn'
        
    - name: Enable Corepack
      run: corepack enable
        
    - name: Setup Yarn
      run: corepack prepare yarn@${{ env.YARN_VERSION }} --activate
        
    - name: Install dependencies
      run: yarn install --immutable
      
    - name: Run linting
      run: yarn lint
      
    - name: Run tests
      run: yarn test
      env:
        NODE_ENV: test
        AWS_REGION: ${{ env.AWS_REGION }}
        AWS_ACCESS_KEY_ID: test
        AWS_SECRET_ACCESS_KEY: test
        TABLE_NAME: ${{ env.TABLE_NAME }}
        QUEUE_NAME: ${{ env.QUEUE_NAME }}
        S3_BUCKET: ${{ env.S3_BUCKET }}
        
    - name: Build application
      run: yarn build
      
    # Step 3: Determine environment and tags
    - name: Determine environment and tags
      id: env-info
      run: |
        # For pull requests, use base_ref (target branch)
        # For push events, use ref (source branch)
        if [[ "${{ github.event_name }}" == "pull_request" ]]; then
          BRANCH="${{ github.base_ref }}"
        else
          BRANCH="${{ github.ref }}"
          BRANCH="${BRANCH#refs/heads/}"
        fi
        
        if [[ "$BRANCH" == "master" ]]; then
          echo "environment=production" >> $GITHUB_OUTPUT
          echo "tag=production" >> $GITHUB_OUTPUT
        elif [[ "$BRANCH" == "staging" ]]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "tag=staging" >> $GITHUB_OUTPUT
        else
          echo "❌ This workflow should only run on staging or master branches"
          echo "Current branch/target: $BRANCH"
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Base ref: ${{ github.base_ref }}"
          exit 1
        fi
        
    # Step 4: Build and Test Production Docker image
    - name: Build and Test Production Docker image
      run: |
        echo "Building production Docker image for ${{ steps.env-info.outputs.tag }} environment..."
        docker build -f ${{ env.DOCKER_PROD_FILE }} -t soundbite-${{ steps.env-info.outputs.tag }}:latest .
        echo "✅ Production Docker image built successfully"
        
        echo "Testing production Docker container..."
        
        # Start container
        docker run -d \
          --name test-${{ steps.env-info.outputs.tag }}-container \
          -p ${{ env.CONTAINER_PORT }}:3000 \
          -e NODE_ENV=${{ steps.env-info.outputs.environment }} \
          -e AWS_REGION=${{ env.AWS_REGION }} \
          -e TABLE_NAME=${{ env.TABLE_NAME }} \
          -e QUEUE_NAME=${{ env.QUEUE_NAME }} \
          -e S3_BUCKET=${{ env.S3_BUCKET }} \
          soundbite-${{ steps.env-info.outputs.tag }}:latest
        
        # Wait for container to start
        for i in {1..${{ env.HEALTH_CHECK_TIMEOUT }}}; do
          if curl -s http://localhost:${{ env.HEALTH_CHECK_PORT }}/health > /dev/null 2>&1; then
            echo "✅ Docker container started successfully"
            break
          fi
          echo "Waiting for container... ($i/${{ env.HEALTH_CHECK_TIMEOUT }})"
          sleep 2
        done
        
        # Test health endpoint
        curl -f http://localhost:${{ env.HEALTH_CHECK_PORT }}/health
        
        # Test API endpoint
        curl -f http://localhost:${{ env.HEALTH_CHECK_PORT }}/
        
        # Clean up
        docker stop test-${{ steps.env-info.outputs.tag }}-container || true
        docker rm test-${{ steps.env-info.outputs.tag }}-container || true
        
        
    # Step 5: Push image to ECR (only on staging branch pushes)
    - name: Configure AWS credentials
      if: github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/master'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/${{ env.AWS_ROLE_NAME }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Login to Amazon ECR
      if: github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/master'
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Push Docker image to ECR
      if: github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/master'
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ${{ env.DOCKER_PROD_FILE }}
        push: true
        tags: |
          ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.env-info.outputs.tag }}
          ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
        cache-from: type=gha
        platforms: linux/amd64
        
    # Step 6: Upload build artifacts
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.env-info.outputs.tag }}-build-artifacts
        path: dist/
        retention-days: 7

